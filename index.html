<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ヘキサゴンパズル</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .vertex {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s ease-in-out;
            border: 3px solid transparent;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .vertex:hover:not(.disabled) {
            transform: scale(1.1);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        .vertex.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background-color: #9ca3af !important; /* Tailwind gray-400 */
            color: #e5e7eb !important; /* Tailwind gray-200 */
        }
        .hexagon-container {
            position: relative;
            width: 250px; /* Adjust as needed */
            height: 250px; /* Adjust as needed */
            margin: 30px auto;
        }
        /* Positioning vertices */
        #vertex-0 { top: 0; left: 50%; transform: translateX(-50%); }
        #vertex-1 { top: 25%; left: 93.3%; transform: translate(-50%, -50%); }
        #vertex-2 { top: 75%; left: 93.3%; transform: translate(-50%, -50%); }
        #vertex-3 { top: 100%; left: 50%; transform: translate(-50%, -100%); }
        #vertex-4 { top: 75%; left: 6.7%; transform: translate(-50%, -50%); }
        #vertex-5 { top: 25%; left: 6.7%; transform: translate(-50%, -50%); }

        /* Color classes */
        .bg-red-custom { background-color: #ef4444; color: #7f1d1d; border-color: #b91c1c; }
        .bg-blue-custom { background-color: #3b82f6; color: #1e3a8a; border-color: #1d4ed8; }
        .bg-yellow-custom { background-color: #f59e0b; color: #78350f; border-color: #b45309; }

        .color-select-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s ease-in-out, transform 0.2s ease-in-out;
        }
        .color-select-btn:hover {
            transform: scale(1.1);
        }
        .color-select-btn.selected {
            border-color: #1f2937; /* gray-800 */
            box-shadow: 0 0 0 2px white, 0 0 0 4px #1f2937; /* Ring effect */
        }
        .solution-step {
            padding: 8px;
            margin-bottom: 4px;
            border-radius: 4px;
            background-color: #f3f4f6; /* gray-100 */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div class="bg-white p-6 md:p-8 rounded-xl shadow-2xl w-full max-w-2xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">ヘキサゴンパズル</h1>

        <div id="custom-color-setup" class="mb-6 p-4 bg-gray-50 rounded-lg shadow">
            <h3 class="text-lg font-semibold mb-3 text-gray-700 text-center">初期カラー設定</h3>
            <div class="grid grid-cols-2 sm:grid-cols-3 gap-x-4 gap-y-3">
                </div>
        </div>

        <div class="hexagon-container mb-6">
            <div class="vertex absolute" id="vertex-0" data-index="0">P1</div>
            <div class="vertex absolute" id="vertex-1" data-index="1">P2</div>
            <div class="vertex absolute" id="vertex-2" data-index="2">P3</div>
            <div class="vertex absolute" id="vertex-3" data-index="3">P4</div>
            <div class="vertex absolute" id="vertex-4" data-index="4">P5</div>
            <div class="vertex absolute" id="vertex-5" data-index="5">P6</div>
        </div>

        <div class="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4 mb-6">
            <button id="solve-button" class="w-full sm:w-auto px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg shadow-md transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">
                自動クリア
            </button>
        </div>

        <!-- <div id="message-area" class="text-center min-h-[50px] p-3 bg-indigo-100 text-indigo-700 rounded-lg shadow">
            初期カラーを設定してください。
        </div> -->

        <div id="solution-area" class="mt-4 p-4 bg-gray-50 rounded-lg shadow max-h-60 overflow-y-auto">
            <h3 class="text-lg font-semibold text-gray-700 mb-2 text-center">解決手順:</h3>
            <div id="solution-steps" class="text-sm text-gray-600">
                </div>
        </div>
    </div>

    <script>
        const NUM_VERTICES = 6;
        const COLORS = ['red', 'blue', 'yellow']; // 0: red, 1: blue, 2: yellow
        const COLOR_NAMES = ['赤', '青', '黄'];
        const COLOR_CLASSES = ['bg-red-custom', 'bg-blue-custom', 'bg-yellow-custom'];

        let vertexColors = Array(NUM_VERTICES).fill(0); 
        let initialCustomColors = [...vertexColors]; 
        let lastClickedVertex = -1;
        
        const vertexElements = Array.from(document.querySelectorAll('.vertex'));
        // const messageAreaElement = document.getElementById('message-area'); // Removed
        const solutionStepsElement = document.getElementById('solution-steps');
        const solveButton = document.getElementById('solve-button');
        const customColorSetupElement = document.getElementById('custom-color-setup').querySelector('.grid');

        // --- Initial Color Setup UI ---
        function renderCustomColorSetup() {
            customColorSetupElement.innerHTML = '';
            for (let i = 0; i < NUM_VERTICES; i++) {
                const controlGroup = document.createElement('div');
                controlGroup.className = 'flex flex-col items-center space-y-1 p-2 bg-white rounded shadow';

                const label = document.createElement('span');
                label.className = 'font-medium text-gray-600';
                label.textContent = `P${i + 1}:`;
                controlGroup.appendChild(label);

                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'flex space-x-1';

                COLORS.forEach((color, colorIndex) => {
                    const btn = document.createElement('button');
                    btn.dataset.vertex = i;
                    btn.dataset.color = colorIndex;
                    btn.className = `color-select-btn ${COLOR_CLASSES[colorIndex]}`;
                    if (initialCustomColors[i] === colorIndex) { 
                        btn.classList.add('selected');
                    }
                    btn.setAttribute('aria-label', `頂点P${i+1}を${COLOR_NAMES[colorIndex]}に設定`);
                    btn.addEventListener('click', handleCustomColorSelect);
                    buttonContainer.appendChild(btn);
                });
                controlGroup.appendChild(buttonContainer);
                customColorSetupElement.appendChild(controlGroup);
            }
        }

        function handleCustomColorSelect(event) {
            const vertexIndex = parseInt(event.target.dataset.vertex);
            const colorIndex = parseInt(event.target.dataset.color);
            
            initialCustomColors[vertexIndex] = colorIndex; 
            vertexColors[vertexIndex] = colorIndex; 

            renderCustomColorSetup(); 
            updateBoard(); 
            resetGameProgress(); // No message needed
        }

        // --- Game Logic ---
        function resetGameProgress() {
            lastClickedVertex = -1;
            solutionStepsElement.innerHTML = ''; 
            solveButton.disabled = false;
            solveButton.classList.remove('opacity-50', 'cursor-not-allowed');
            solveButton.textContent = '自動クリア'; // Reset button text if it was "解析中..."
            vertexElements.forEach(v => v.classList.remove('disabled')); 
        }

        function initGame() {
            vertexColors = [...initialCustomColors]; 
            renderCustomColorSetup(); 
            updateBoard(); 
            resetGameProgress();
        }

        function updateBoard() {
            vertexElements.forEach((vertex, index) => {
                vertex.classList.remove(...COLOR_CLASSES, 'disabled');
                vertex.classList.add(COLOR_CLASSES[vertexColors[index]]);
                vertex.textContent = `P${index + 1}`;

                if (index === lastClickedVertex) {
                    vertex.classList.add('disabled');
                }
            });
        }

        function handleVertexClick(index) {
            if (index === lastClickedVertex) {
                // No messageArea to display "同じ頂点を連続して選択できません。"
                console.warn('Cannot select the same vertex consecutively.');
                return;
            }
            
            const leftNeighbor = (index - 1 + NUM_VERTICES) % NUM_VERTICES;
            const rightNeighbor = (index + 1) % NUM_VERTICES;

            vertexColors[leftNeighbor] = (vertexColors[leftNeighbor] + 1) % 3;
            vertexColors[rightNeighbor] = (vertexColors[rightNeighbor] + 1) % 3;

            lastClickedVertex = index;
            updateBoard();
            
            // No explicit win message here. User sees colors are the same.
            // checkWin() is still used by solver.
        }

        function checkWin() {
            if (vertexColors.length === 0) return false;
            const firstColor = vertexColors[0];
            return vertexColors.every(color => color === firstColor);
        }

        vertexElements.forEach(vertex => {
            vertex.addEventListener('click', () => {
                const index = parseInt(vertex.dataset.index);
                if (!vertex.classList.contains('disabled')) { 
                     handleVertexClick(index);
                }
            });
        });
        
        // --- Solver Logic (BFS) ---
        async function solveGame() {
            if (checkWin()) {
                // messageAreaElement.textContent = '既に全ての頂点の色が同じです。'; // Removed
                solutionStepsElement.innerHTML = '<div class="text-center">既にクリア状態です。</div>';
                return;
            }

            solveButton.disabled = true;
            solveButton.classList.add('opacity-50', 'cursor-not-allowed');
            solveButton.textContent = '解析中...';
            // messageAreaElement.textContent = '最適な手順を探索しています...'; // Removed
            solutionStepsElement.innerHTML = '<div class="text-center">探索中...</div>';

            await new Promise(resolve => setTimeout(resolve, 50));

            const queue = [];
            const initialBoardColors = [...vertexColors]; 
            const initialBoardLastClicked = lastClickedVertex;

            queue.push({ colors: initialBoardColors, lastClicked: initialBoardLastClicked, path: [] });
            
            const visited = new Set();
            visited.add(initialBoardColors.join(',') + '|' + initialBoardLastClicked);

            let solutionPath = null;
            let iterations = 0;
            const MAX_ITERATIONS = 50000; 

            while (queue.length > 0) {
                iterations++;
                if (iterations > MAX_ITERATIONS) {
                    console.error("Solver exceeded max iterations.");
                    // messageAreaElement.textContent = '解析が複雑すぎるか、解がないため中断しました。'; // Removed
                    solutionStepsElement.innerHTML = '<div class="text-center text-red-500">解を見つけられませんでした。盤面を確認してください。</div>';
                    solveButton.disabled = false;
                    solveButton.classList.remove('opacity-50', 'cursor-not-allowed');
                    solveButton.textContent = '自動クリア';
                    return;
                }

                const currentState = queue.shift();
                const currentColors = currentState.colors;
                const currentLastClicked = currentState.lastClicked;
                const currentPath = currentState.path;

                const firstColor = currentColors[0];
                if (currentColors.every(c => c === firstColor)) {
                    solutionPath = currentPath;
                    break; 
                }

                for (let i = 0; i < NUM_VERTICES; i++) {
                    if (i === currentLastClicked) continue; 

                    const newColors = [...currentColors];
                    const left = (i - 1 + NUM_VERTICES) % NUM_VERTICES;
                    const right = (i + 1) % NUM_VERTICES;

                    newColors[left] = (newColors[left] + 1) % 3;
                    newColors[right] = (newColors[right] + 1) % 3;

                    const newStateKey = newColors.join(',') + '|' + i;

                    if (!visited.has(newStateKey)) {
                        visited.add(newStateKey);
                        const newPath = [...currentPath, i];
                        queue.push({ colors: newColors, lastClicked: i, path: newPath });
                    }
                }
            }
            
            solveButton.textContent = '自動クリア'; 

            if (solutionPath) {
                // messageAreaElement.textContent = `解決策が見つかりました！ (${solutionPath.length}手で達成可能)`; // Removed
                displaySolution(solutionPath);
            } else {
                // messageAreaElement.textContent = '解決策が見つかりませんでした。'; // Removed
                solutionStepsElement.innerHTML = '<div class="text-center text-red-500">現在の盤面からクリアする手順は見つかりませんでした。</div>';
            }
            solveButton.disabled = false; 
            solveButton.classList.remove('opacity-50', 'cursor-not-allowed');
        }

        function displaySolution(path) {
            solutionStepsElement.innerHTML = ''; 
            if (path.length === 0) { 
                 solutionStepsElement.innerHTML = '<div class="text-center">既にクリア状態か、手順は不要です。</div>';
                 return;
            }
            path.forEach((vertexIndex, stepNum) => {
                const stepElement = document.createElement('div');
                stepElement.classList.add('solution-step');
                stepElement.textContent = `${stepNum + 1}. 頂点 P${vertexIndex + 1} を選択`;
                solutionStepsElement.appendChild(stepElement);
            });
        }
        
        solveButton.addEventListener('click', solveGame);

        // Initial setup on page load
        renderCustomColorSetup(); 
        initGame(); 
        // No initial message to set in a messageArea

    </script>
</body>
</html>
